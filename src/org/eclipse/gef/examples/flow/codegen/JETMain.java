/**
 * 
 */
package org.eclipse.gef.examples.flow.codegen;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.List;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.ResourceAttributes;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;

import org.eclipse.emf.codegen.jet.JETEmitter;
import org.eclipse.emf.codegen.jet.JETException;
import org.eclipse.emf.codegen.merge.java.JControlModel;
import org.eclipse.emf.codegen.merge.java.JMerger;
import org.eclipse.emf.codegen.merge.java.facade.FacadeHelper;
import org.eclipse.emf.codegen.util.CodeGenUtil;
import org.eclipse.emf.common.util.BasicMonitor;
import org.eclipse.emf.common.util.DiagnosticException;
import org.eclipse.emf.common.util.Monitor;



/**
 * @author antani
 *
 */
/**
 * This class encapsulates access to the JET and JMerge packages.
 * 
 * @author Remko Popma
 * @version $Revision: 1.5 $ ($Date: 2006/12/29 21:12:36 $)
 */

public class JETMain {
	

	
	  private Config mConfig = null;

	  public JETMain(Config config)
	  {
	    mConfig = config;
	  }

	  /**
	   * Invokes the JET template specified in the <code>Config</code> with the
	   * model specified in the <code>Config</code> and returns the generated text
	   * as a String.
	   * <p>
	   * This implementation uses a <code>JETEmitter</code> to translate the
	   * template to a Java implementation class. The translated class is created in
	   * a hidden project called <code>.JETEmitters</code>.
	   * <p>
	   * In order to be able to compile the translated template implementation
	   * class, the classes used by the model specified in the <code>Config</code>
	   * must be available in the classpath. For this reason, this method sets the
	   * first runtime library of the plugin specified in the <code>Config</code>
	   * as a classpath variable to the <code>.JETEmitters</code> project.
	   * 
	   * @param monitor
	   *          the progress monitor to use. May be <code>null</code>.
	   * @return the source code text generated by the JET template
	   * @throws CoreException
	   */
	  public String generate(IProgressMonitor monitor) throws CoreException
	  {
	    try
	    {
	      monitor = createIfNull(monitor);
	      Config config = getConfig();
	      //String pluginId = "org.netapp.floweditor";
	      String pluginId = config.getPluginId();
	      String base = Platform.getBundle(pluginId).getEntry("/").toString();
	      //Path path = new Path("templates/NetAppFlowMain.javajet"); 
	      //URL fileURL = Platform.find(Platform.getBundle(pluginId), path);
	      
	      //System.out.println("File path : " + fileURL.toString());
	      
	      String relativeUri = "templates/NetAppFlowMain.javajet";
	      
	      String templateFullUri= config.getTemplateFullUri();
	      System.out.println("templateFullUri -- "+ templateFullUri);
	      System.out.println("templateFullUri -- "+ base+relativeUri);	
	      
	      //templateFullUri = "C:\\runtime-EclipseApplication\\templates\\NetAppFlowMain.javajet";
	      JETEmitter emitter = new JETEmitter(base+relativeUri, getClass().getClassLoader());
	      System.out.println(config.getClasspathVariable());
	      
	      emitter.addVariable(config.getClasspathVariable(), config.getPluginId());
	      List clList = emitter.getClasspathEntries();
	      for(int i=0; i< clList.size();i++){
	    	 System.out.println(">>>>"  +  clList.get(i).toString());
	    	  
	      }
	  
	      Monitor sub = new BasicMonitor.EclipseSubProgress(monitor, 1);
	      String result = emitter.generate(sub, new Object []{ config.getModel() });
	      monitor.worked(1);
	      return result;
	    }
	    catch (JETException exception)
	    {
	      //throw DiagnosticException.toCoreException(exception);
	    	exception.printStackTrace();
	    	throw DiagnosticException.toCoreException(exception);
	    }
	  }
	  public String generateAll(IProgressMonitor monitor, String fileName) throws CoreException
	  {
	    try
	    {
	      monitor = createIfNull(monitor);
	      Config config = getConfig();
	      String pluginId = "org.netapp.floweditor";
	      String base = Platform.getBundle(pluginId).getEntry("/").toString();
	      Path path = new Path("templates/HelloDfm.javajet"); 
	      URL fileURL = Platform.find(Platform.getBundle(pluginId), path);
	      
	      System.out.println("File path : " + fileURL.toString());
	      
	      String relativeUri = "templates/HelloDfm.javajet";
	      
	      String templateFullUri= config.getTemplateFullUri();
	      System.out.println("templateFullUri -- "+ base+relativeUri);	      
	      JETEmitter emitter = new JETEmitter(base+relativeUri, getClass().getClassLoader());
	      System.out.println(config.getClasspathVariable());
	      
	     // emitter.addVariable(config.getClasspathVariable(), config.getPluginId());
	      Monitor sub = new BasicMonitor.EclipseSubProgress(monitor, 1);
	      String result = emitter.generate(sub, new Object []{ config.getModel() });
	      monitor.worked(1);
	      return result;
	    }
	    catch (JETException exception)
	    {
	      //throw DiagnosticException.toCoreException(exception);
	    	exception.printStackTrace();
	    	throw DiagnosticException.toCoreException(exception);
	    }
	  }
	  /**
	   * Merges the specified emitterResult with the contents of an existing file
	   * and returns the result. The existing file is not modified.
	   * <p>
	   * The location of the file to merge with is found by finding or creating the
	   * container (folder) for the <code>Config</code>'s package in the
	   * <code>Config</code>'s target folder. The name of the file to merge with
	   * is the <code>Config</code>'s target file.
	   * 
	   * @param monitor
	   *          the progress monitor to use. May be <code>null</code>.
	   * @param emitterResult
	   *          generated content to merge with the existing content
	   * @return the result of merging the specified generated contents with the
	   *         existing file
	   * @throws CoreException
	   *           if an error occurs accessing the contents of the file
	   */
	  public String merge(IProgressMonitor monitor, String sourceFilePath) throws CoreException
	  {
	    monitor = createIfNull(monitor);

	    Config config = getConfig();
	    IContainer container = findOrCreateContainer(monitor, config.getTargetFolder(), config.getPackageName());
	    if (container == null)
	    {
	      throw 
	        new CoreException
	          (new Status
	             (IStatus.ERROR,
	              "org.eclipse.emf.examples.jet.article2",
	              0,
	              "Could not find or create container for package " + config.getPackageName() + " in " + config.getTargetFolder(),
	              null));
	    }
	    IFile sourceFile = container.getFile(new Path(sourceFilePath));
	    IFile targetFile = container.getFile(new Path(config.getTargetFile()));
	    InputStream is = sourceFile.getContents(true);
	    StringBuffer sb = new StringBuffer("");
	    int data=0;
		try {
			data = is.read();
		
		    //sb.append(""+data);
		    while(data != -1){
		    	sb.append(""+data);
		    	data = is.read();
		    }
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	    String emitterResult = sb.toString();
	    if (!targetFile.exists())
	    {
	      monitor.worked(1);
	      return emitterResult;
	    }

	    JControlModel jControlModel = new JControlModel();
	    jControlModel.initialize(CodeGenUtil.instantiateFacadeHelper(JMerger.DEFAULT_FACADE_HELPER_CLASS), config.getMergeXmlFullUri());
	    JMerger jMerger = new JMerger(jControlModel);
	    jMerger.setSourceCompilationUnit(jMerger.createCompilationUnitForContents(emitterResult));
	    jMerger.setTargetCompilationUnit(jMerger.createCompilationUnitForInputStream(targetFile.getContents(true)));

	    String string = jControlModel.getFacadeHelper().getOriginalContents(jMerger.getTargetCompilationUnit());
		String contents = string;
		String originalContents2 = contents;
		String originalContents = originalContents2;
		String oldContents = originalContents;

	    jMerger.merge();
	    monitor.worked(1);

	    String result = jMerger.getTargetCompilationUnitContents();
	    if (oldContents.equals(result))
	    {
	      return result;
	    }

	    if (!targetFile.isReadOnly())
	    {
	      return result;
	    }

	    // The file may be read-only because it is checked out
	    // by a VCM component. Here we ask permission to change the file.
	    if (targetFile.getWorkspace().validateEdit(new IFile []{ targetFile }, new SubProgressMonitor(monitor, 1)).isOK())
	    {

	      jMerger.setTargetCompilationUnit(jMerger.createCompilationUnitForInputStream(targetFile.getContents(true)));
	      jMerger.remerge();
	      return jMerger.getTargetCompilationUnitContents();
	    }
	    return result;
	  }

	  /**
	   * Saves the specified contents to a location specified by the
	   * <code>Config</code> settings. The location of the file to save is found
	   * by finding or creating the container (folder) for the <code>Config</code>
	   * 's package in the <code>Config</code>'s target folder. The name of the
	   * file to save is the <code>Config</code>'s target file.
	   * 
	   * @param monitor
	   *          the progress monitor to use. May be <code>null</code>.
	   * @param contents
	   *          the byte contents of the file to save
	   * @throws CoreException
	   */
	  public IFile save(IProgressMonitor monitor, byte[] contents) throws CoreException
	  {
	    monitor = createIfNull(monitor);

	    Config config = getConfig();
	    IContainer container = findOrCreateContainer(monitor, config.getTargetFolder(), config.getPackageName());
	    if (container == null)
	    {
	      throw 
	        new CoreException
	          (new Status
	             (IStatus.ERROR,
	              "org.eclipse.emf.examples.jet.article2",
	              0,
	              "Could not find or create container for package " + config.getPackageName() + " in " + config.getTargetFolder(),
	              null));
	    }
	    IFile targetFile = container.getFile(new Path(config.getTargetFile()));
	    IFile result = getWritableTargetFile(targetFile, container, config.getTargetFile());

	    InputStream newContents = new ByteArrayInputStream(contents);
	    if (result.exists())
	    {
	      result.setContents(newContents, true, true, new SubProgressMonitor(monitor, 1));
	    }
	    else
	    {
	      result.create(newContents, true, new SubProgressMonitor(monitor, 1));
	    }
	    return result;
	  }

	  /**
	   * Returns a non-null progress monitor.
	   * 
	   * @param monitor
	   *          an existing progress monitor
	   * @return a new <code>NullProgressMonitor</code> if the specified monitor
	   *         is <code>null</code>, or the existing monitor otherwise
	   */
	  private IProgressMonitor createIfNull(IProgressMonitor monitor)
	  {
	    if (monitor == null)
	    {
	      return new NullProgressMonitor();
	    }
	    return monitor;
	  }

	  private IContainer findOrCreateContainer(IProgressMonitor progressMonitor, String targetDirectory, String packageName) throws CoreException
	  {

	    IPath outputPath = new Path(targetDirectory + "/" + packageName.replace('.', '/'));
	    progressMonitor.beginTask("", 4);

	    IProgressMonitor sub = new SubProgressMonitor(progressMonitor, 1);
	    IPath localLocation = null; // use default
	    IContainer container = CodeGenUtil.EclipseUtil.findOrCreateContainer(outputPath, true, localLocation, sub);
	    return container;
	  }

	  /**
	   * Returns a <code>IFile</code> that can be written to. If the specified
	   * file is read-write, it is returned unchanged. If the specified file is
	   * read-only and {@link Config#isForceOverwrite()}returns <code>true</code>,
	   * the file is made writable, otherwise a new file is returned in the
	   * specified container with filename <code>"." + fileName + ".new"</code>.
	   * 
	   * @param container
	   *          container to create the new file in if the specified file cannot
	   *          be made writable
	   * @param targetFile
	   *          the file to make writable
	   * @param fileName
	   *          used to create a new file name if the specified file cannot be
	   *          made writable
	   * @return a <code>IFile</code> that can be written to
	   */
	  private IFile getWritableTargetFile(IFile targetFile, IContainer container, String fileName)
	  {
	    if (targetFile.isReadOnly())
	    {
	      if (getConfig().isForceOverwrite())
	      {
	        ResourceAttributes attributes = targetFile.getResourceAttributes();
	        attributes.setReadOnly(false);
	        try
	        {
	          targetFile.setResourceAttributes(attributes);
	        }
	        catch (CoreException e)
	        {
	          // Ignore
	        }
	      }
	      else
	      {
	        targetFile = container.getFile(new Path("." + fileName + ".new"));
	      }
	    }
	    return targetFile;
	  }

	  /**
	   * Returns the <code>Config</code> object
	   * 
	   * @return the <code>Config</code> object
	   */
	  protected Config getConfig()
	  {
	    return mConfig;
	  }
	

}
